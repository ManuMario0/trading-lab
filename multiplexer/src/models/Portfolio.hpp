#pragma once
#include <map>
#include <nlohmann/json.hpp>
#include <string>
#include <vector>

struct InstrumentData {
  std::string symbol;
  std::string exchange;
};

struct Instrument {
  std::string type; // "Stock", "Future", etc.
  InstrumentData data;

  // Helper for map keys
  bool operator<(const Instrument &other) const {
    if (type != other.type)
      return type < other.type;
    if (data.symbol != other.data.symbol)
      return data.symbol < other.data.symbol;
    return data.exchange < other.data.exchange;
  }

  // Helper to stringify for logging
  std::string to_string() const { return data.symbol + "." + data.exchange; }
};

struct TargetPortfolio {
  std::string multiplexer_id;
  // Map of Instrument -> Weight (0.0 to 1.0+)
  std::map<Instrument, double> target_weights;
  // We ignore target_positions for now as Multiplexers work in weights

  TargetPortfolio() = default;
};

// JSON Serialization Logic
// ------------------------

inline void to_json(nlohmann::json &j, const InstrumentData &p) {
  j = nlohmann::json{{"symbol", p.symbol}, {"exchange", p.exchange}};
}

inline void from_json(const nlohmann::json &j, InstrumentData &p) {
  j.at("symbol").get_to(p.symbol);
  j.at("exchange").get_to(p.exchange);
}

inline void to_json(nlohmann::json &j, const Instrument &p) {
  j = nlohmann::json{{"type", p.type}, {"data", p.data}};
}

inline void from_json(const nlohmann::json &j, Instrument &p) {
  j.at("type").get_to(p.type);
  j.at("data").get_to(p.data);
}

inline void to_json(nlohmann::json &j, const TargetPortfolio &p) {
  // Rust HashMap<Instrument, f64> serializes as a Map if keys are strings,
  // or a List of Tuples [[key, val], ...] if keys are complex objects.
  // Since Instrument is a complex object, it will be [[inst, weight], ...].
  std::vector<std::pair<Instrument, double>> weight_list;
  for (auto const &[key, val] : p.target_weights) {
    weight_list.push_back({key, val});
  }

  j = nlohmann::json{{"type", "TargetPortfolio"},
                     {"data",
                      {{"multiplexer_id", p.multiplexer_id},
                       {"target_weights", weight_list},
                       {"target_positions", nullptr}}}};
}

inline void from_json(const nlohmann::json &j, TargetPortfolio &p) {
  // We expect structure: { "type": "TargetPortfolio", "data": { ... } }
  // Or just the data object directly if simplified, but let's stick to the
  // structure generated by to_json

  // Check if wrapped in type/data
  const nlohmann::json *data_ptr = &j;
  if (j.contains("data")) {
    data_ptr = &j["data"];
  }

  data_ptr->at("multiplexer_id").get_to(p.multiplexer_id);

  // target_weights is a list of [Instrument, double] pairs
  // e.g. [[{"type":..., "data":...}, 1.0], ...]
  if (data_ptr->contains("target_weights")) {
    auto &weights_array = data_ptr->at("target_weights");
    for (auto &item : weights_array) {
      // item is [Instrument, double]
      Instrument inst = item[0].get<Instrument>();
      double w = item[1].get<double>();
      p.target_weights[inst] = w;
    }
  }
}
