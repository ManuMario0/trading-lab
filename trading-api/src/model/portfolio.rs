use crate::model::allocation::Position;
use crate::model::instrument::InstrumentId;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Represents a cash balance in a specific currency.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct CashBalance {
    /// The currency code (e.g., "USD", "EUR").
    pub currency: String,
    /// The total amount of cash held.
    pub amount: f64,
    /// The amount of cash available for trading (after margin requirements, open orders, etc.).
    pub available: f64,
}

impl CashBalance {
    pub fn new(currency: &str, amount: f64, available: f64) -> Self {
        Self {
            currency: currency.to_string(),
            amount,
            available,
        }
    }
}

/// Represents the consolidated state of an account, including cash and positions.
/// This structure is used for both the "Actual" state (from Execution Engine)
/// and the "Target" state (from Portfolio Manager).
#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq)]
pub struct Portfolio {
    /// Timestamp of the portfolio state (unix millis).
    pub timestamp: u128,
    /// Cash balances keyed by currency code.
    pub cash: HashMap<String, CashBalance>,
    /// Positions keyed by InstrumentId.
    pub positions: HashMap<InstrumentId, Position>,
    /// Total Net Asset Value (Equity) estimation in the base currency.
    pub total_equity: f64,
}

impl Portfolio {
    pub fn new() -> Self {
        Self {
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis(),
            cash: HashMap::new(),
            positions: HashMap::new(),
            total_equity: 0.0,
        }
    }

    pub fn with_equity(mut self, equity: f64) -> Self {
        self.total_equity = equity;
        self
    }

    pub fn set_cash(&mut self, currency: &str, amount: f64) {
        self.cash.insert(
            currency.to_string(),
            CashBalance::new(currency, amount, amount),
        );
    }

    pub fn update_position(&mut self, instrument_id: InstrumentId, quantity: f64) {
        if quantity == 0.0 {
            self.positions.remove(&instrument_id);
        } else {
            self.positions
                .insert(instrument_id, Position::new(instrument_id, quantity));
        }
    }

    pub fn get_position(&self, instrument_id: &InstrumentId) -> Option<&Position> {
        self.positions.get(instrument_id)
    }

    pub fn get_cash(&self, currency: &str) -> Option<&CashBalance> {
        self.cash.get(currency)
    }
}

/// NewType wrapper representing the ACTUAL state of the portfolio.
/// This comes from the Execution Engine or Broker.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Actual(pub Portfolio);

/// NewType wrapper representing the TARGET state of the portfolio.
/// This is generated by the Portfolio Manager (Policy Checks/Optimization).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Target(pub Portfolio);
